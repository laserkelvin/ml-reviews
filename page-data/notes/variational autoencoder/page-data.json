{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/notes/variational autoencoder","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"needs-expanding\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"variational-autoencoder\"\n  }, \"variational autoencoder\"), mdx(\"p\", null, \"A probabilistic \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/architecture\",\n    \"title\": \"architecture\"\n  }, \"[[architecture]]\"), \" from the family of [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"autoencoders\",\n    \"title\": \"autoencoders\"\n  }, \"autoencoders\"), \"]. The self-learned representation is used to parameterize a probability distribution (i.e. the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/posterior-distribution\",\n    \"title\": \"posterior distribution\"\n  }, \"[[posterior distribution]]\"), \"), from which a decoder can draw samples from to generate a range of outputs. We can either directly predict the mean of the distribution, or perform sampling over the distribution to obtain #uncertainty estimates.\"), mdx(\"p\", null, \"Is a sub-category of [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"bayesian-neural-networks\",\n    \"title\": \"bayesian-neural-networks\"\n  }, \"bayesian-neural-networks\"), \"], whereby variational inference is done, usually in contrast to full \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/MCMC\",\n    \"title\": \"MCMC\"\n  }, \"[[MCMC]]\"), \" sampling.\"), mdx(\"p\", null, \"Problem with VAEs is that they are susceptible to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/posterior-collapse\",\n    \"title\": \"posterior collapse\"\n  }, \"[[posterior collapse]]\"), \", where a single output is produced regardless: this is when the decoder ignores the latent variable completely, and becomes a deterministic model.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://lilianweng.github.io/lil-log/2018/08/12/from-autoencoder-to-beta-vae.html\"\n  }, \"This blog by Lilian Weng\"), \" has an incredibly in-depth description of the theory behind VAEs.\"), mdx(\"h2\", {\n    \"id\": \"types-of-vaes\"\n  }, \"Types of VAEs\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/beta-VAE\",\n    \"title\": \"beta-VAE\"\n  }, \"[[beta-VAE]]\"), \" provides a tuning parameter, $\\\\beta$, that attempts to force disentangling of the latent vector into unit Gaussian priors. Relatively easy to understand and implement, however quite readily suffers from \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/posterior-collapse\",\n    \"title\": \"posterior collapse\"\n  }, \"[[posterior collapse]]\"), \".\")), mdx(\"p\", null, \"[posterior collapse]\", \": posterior collapse \\\"posterior collapse\\\"\\n\", \"[posterior collapse]\", \": posterior collapse \\\"posterior collapse\\\"\"), mdx(\"p\", null, \"[posterior collapse]\", \": posterior collapse \\\"posterior collapse\\\"\\n\", \"[posterior collapse]\", \": posterior collapse \\\"posterior collapse\\\"\"), mdx(\"p\", null, \"[posterior collapse]\", \": posterior collapse \\\"posterior collapse\\\"\\n\", \"[posterior collapse]\", \": posterior collapse \\\"posterior collapse\\\"\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"uncertainty\"\n  }, \"uncertainty\"), mdx(\"h2\", {\n    \"id\": \"reinforcement-learning\"\n  }, \"Reinforcement learning\"), mdx(\"p\", null, \"In the context of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/reinforcement-learning\",\n    \"title\": \"reinforcement learning\"\n  }, \"[[reinforcement learning]]\"), \", according to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/decision-making-book\",\n    \"title\": \"decision-making-book\"\n  }, \"[[decision-making-book]]\"), \" uncertainty comprises:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"outcome uncertainty\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"what effect will our action have\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"model uncertainty\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"our model of the problem is uncertain\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"state uncertainty\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the true state is uncertain\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be modelled as a \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/partially-observable-markov-decision-process\",\n    \"title\": \"partially-observable-markov-decision-process\"\n  }, \"[[partially-observable-markov-decision-process]]\"), \"\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"interaction uncertainty\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"behavior of other agents is uncertain\")))), mdx(\"p\", null, \"[reinforcement learning]\", \": reinforcement learning \\\"reinforcement learning\\\"\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"bd86e722-d930-5c0d-8e57-d72278691df5","fields":{"slug":"/notes/uncertainty","title":"uncertainty"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"autoencoders\"\n  }, \"autoencoders\"), mdx(\"p\", null, \"A type of machine learning \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/architecture\",\n    \"title\": \"architecture\"\n  }, \"[[architecture]]\"), \" that encodes data into a self-learned representation.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"a4f94698-6ed6-5e36-bae3-d4b2fc873702","fields":{"slug":"/notes/autoencoders","title":"autoencoders"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"bayesian-neural-networks\"\n  }, \"bayesian-neural-networks\"), mdx(\"p\", null, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/neural-networks\",\n    \"title\": \"neural networks\"\n  }, \"[[neural networks]]\"), \" in a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/bayesian\",\n    \"title\": \"bayesian\"\n  }, \"[[bayesian]]\"), \" formalism. The general idea is that the initialization schemes for neural networks act as priors, and by training the network, we end up with a parameterized \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/posterior-distribution\",\n    \"title\": \"posterior distribution\"\n  }, \"[[posterior distribution]]\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"f9da958d-5c93-5082-898e-0f3d0a4b0dd1","fields":{"slug":"/notes/bayesian-neural-networks","title":"bayesian-neural-networks"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"posterior-collapse\"\n  }, \"posterior collapse\"), mdx(\"p\", null, \"An issue primarily related to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/variational-autoencoder\",\n    \"title\": \"variational autoencoder\"\n  }, \"[[variational autoencoder]]\"), \" models, where the output becomes deterministic in a supposedly probabilistic model.\"), mdx(\"p\", null, \"Some annealing schemes, such as [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"cyclical-annealing-schedule-a-simple-approach-to-mitigating-kl-vanishing\",\n    \"title\": \"cyclical-annealing-schedule-a-simple-approach-to-mitigating-kl-vanishing\"\n  }, \"cyclical-annealing-schedule-a-simple-approach-to-mitigating-kl-vanishing\"), \"] is developed to help VAEs learn to encode good latent variables \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"and\"), \" good accuracy in the outputs.\"), mdx(\"p\", null, \"[variational autoencoder]\", \": variational autoencoder \\\"variational autoencoder\\\"\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"568fb177-3b40-5259-99b5-3a6c253faa0f","fields":{"slug":"/notes/posterior collapse","title":"posterior collapse"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"ml-reviews\"\n  }, \"ML Reviews\"), mdx(\"p\", null, \"Welcome to ML Reviews: a Zettelkasten for learning about machine learning methodologies. Primarily, I've been writing notes for myself, with the intention of publishing them here in the hopes of benefiting others.\"), mdx(\"p\", null, \"In lieu of a real index page, here are some topics that will get you started on a journey:\"), mdx(\"h2\", {\n    \"id\": \"paper-reviews\"\n  }, \"Paper reviews\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"notes/scalable-uncertainties-from-deep-ensembles\",\n    \"title\": \"scalable-uncertainties-from-deep-ensembles\"\n  }, \"scalable-uncertainties-from-deep-ensembles\"), \"]; a review on deep ensembles\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"notes/cyclical-annealing-schedule-a-simple-approach-to-mitigating-kl-vanishing\",\n    \"title\": \"cyclical-annealing-schedule-a-simple-approach-to-mitigating-kl-vanishing\"\n  }, \"cyclical-annealing-schedule-a-simple-approach-to-mitigating-kl-vanishing\"), \"]; a review on $\\\\beta$-VAE cyclic annealing\")), mdx(\"h2\", {\n    \"id\": \"topics\"\n  }, \"Topics\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/variational-autoencoder\",\n    \"title\": \"variational autoencoder\"\n  }, \"[[variational autoencoder]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/fast-gradient-sign-method\",\n    \"title\": \"fast gradient sign method\"\n  }, \"[[fast gradient sign method]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"notes/flux-notes\",\n    \"title\": \"flux-notes\"\n  }, \"flux-notes\"), \"]\")), mdx(\"p\", null, \"[variational autoencoder]\", \": notes/variational autoencoder \\\"variational autoencoder\\\"\\n\", \"[fast gradient sign method]\", \": notes/fast gradient sign method \\\"fast gradient sign method\\\"\"), mdx(\"p\", null, \"[variational autoencoder]\", \": notes/variational autoencoder \\\"variational autoencoder\\\"\\n\", \"[fast gradient sign method]\", \": notes/fast gradient sign method \\\"fast gradient sign method\\\"\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"be8ae56f-15a1-5eec-9f16-43ec9bc7a323","fields":{"slug":"/readme","title":"ML Reviews"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"papers\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"vicreg-variance-invariance-covariance-regularization-for-self-supervised-learning\"\n  }, \"vicreg: Variance-invariance-covariance regularization for self-supervised learning\"), mdx(\"h2\", {\n    \"id\": \"arxiv\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"https://arxiv.org/abs/2105.04906\"\n  }, \"arxiv\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"First written\"), \": Sep/03/2021, 09:20:52\"), mdx(\"h2\", {\n    \"id\": \"summary\"\n  }, \"Summary\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Un/self-supervised learning of representations is difficult: embeddings can likely end up with highly correlated features\", mdx(\"sup\", {\n    parentName: \"li\",\n    \"id\": \"fnref-1\"\n  }, mdx(\"a\", {\n    parentName: \"sup\",\n    \"href\": \"#fn-1\",\n    \"className\": \"footnote-ref\"\n  }, \"1\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We also want to preserve the idea that similar inputs should result in similar encodings, with the most straightforward result being the same embedding regardless of inputs (i.e. a \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"collapse\"), \"). This also involves some clustering heuristic that might not be simple.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Conventionally, good embeddings can be obtained through \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/contrastive-learning\",\n    \"title\": \"contrastive-learning\"\n  }, \"[[contrastive-learning]]\"), \", forcing dissimilar inputs to have different embeddings, and vice versa\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Contrastive learning is expensive, however, because to do it well you have to find examples and counterexamples during training; e.g. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/triplet-loss\",\n    \"title\": \"triplet-loss\"\n  }, \"[[triplet-loss]]\"), \" variants.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"VICReg encodes three heuristics as a form of regularization: variance, invariance, and covariance\")), mdx(\"h2\", {\n    \"id\": \"useful-embeddings\"\n  }, \"Useful embeddings\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The requirements typically are:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Similar inputs -> similar embeddings (i.e. clustering)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dissimilar inputs -> dissimilar embeddings (i.e. contrast)\")))), mdx(\"h2\", {\n    \"id\": \"vic-regularization\"\n  }, \"VIC regularization\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"...the architecture is completely symmetric and consists of an encoder $f\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\\theta$ that outputs the final representations, followed by a project $h\"), \"\\\\phi$ that maps the representations into projections in a embedding space where the loss function will be computed.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Projector gets rid of low-level information in the representations, and is only used for computing the loss (i.e. not used for actual tasks)\")), mdx(\"h3\", {\n    \"id\": \"notation\"\n  }, \"Notation\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Symbol\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Meaning\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$Z$, $Z'$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Batch of embeddings, for either network\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$Y$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The representation used for tasks\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$n$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Batch size\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$d$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Embedding dimensionality\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$v$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Variance (regularization)\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\epsilon$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Small scalar for stability\")))), mdx(\"h3\", {\n    \"id\": \"architecture\"\n  }, \"Architecture\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"561px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/ml-reviews/static/d8ad198cf77bbf9ec343d435da74a77c/09e48/2021-09-03-09-42-34.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"56.42857142857143%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB0UlEQVQoz11SiZKiQAzl/z/N8liVy3F0ALmhOQRUPHiTRHGtSVU63bnzOhpeNAwDPmkYHiL7/oLj8YjHfXj7nc9n5HmOKIrQti2ut9vbpvExJmuaBq7r4XTq4MUKtpsiTnMkSYx9uIETb1FWJeqqxnw+x2w6Jd8T6roWKQnHzNwFV/ze7dBSYifMYOxDFNVRAr59E1+ejqqucL1esd1ucTgcpJHH44GxMY0TOY7zHIsMI1/OJy71DLhTACFw6++SjO1FUaCqKhn5EzatLEupxuNy277vi1OUlTL2sWmlwzDzEKsATdvgRpjpuo71ei13juv7/pmQFQwyB0VhiB2NXBFO+yDDv22AMMmhVI4vfw39ZwZV5OK/Wq1gWZZ03HUdLpfLfww/icd5tv9H//r1kTgpY83ykzQej1tmPLIsE2xypVARFIokvxmWkXld2JfvimxsT9MUGTHn0TzXhWmaMAwDi8UCk8lE3rZty5uxmtJ68JoYpNf1tWDHPJ/NMCM929k3SRJoPn09BxmGjuVyKcn4vdlsCCMbJhXiYC5oWabYpQHyYQxt23o3pFQBLctSWpsfeJ4n6xMEAf30ge6urJJgRaCz5JFG2b10zHxnHX/QL/oHPYhEOSSBAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"2021 09 03 09 42 34\",\n    \"title\": \"2021 09 03 09 42 34\",\n    \"src\": \"/ml-reviews/static/d8ad198cf77bbf9ec343d435da74a77c/410f3/2021-09-03-09-42-34.png\",\n    \"srcSet\": [\"/ml-reviews/static/d8ad198cf77bbf9ec343d435da74a77c/0d3e1/2021-09-03-09-42-34.png 140w\", \"/ml-reviews/static/d8ad198cf77bbf9ec343d435da74a77c/6b1e2/2021-09-03-09-42-34.png 281w\", \"/ml-reviews/static/d8ad198cf77bbf9ec343d435da74a77c/410f3/2021-09-03-09-42-34.png 561w\", \"/ml-reviews/static/d8ad198cf77bbf9ec343d435da74a77c/99072/2021-09-03-09-42-34.png 842w\", \"/ml-reviews/static/d8ad198cf77bbf9ec343d435da74a77c/09e48/2021-09-03-09-42-34.png 974w\"],\n    \"sizes\": \"(max-width: 561px) 100vw, 561px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"h3\", {\n    \"id\": \"variance\"\n  }, \"Variance\"), mdx(\"p\", null, \"The variance regularization term is given by a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hinge-loss\",\n    \"title\": \"hinge-loss\"\n  }, \"[[hinge-loss]]\"), \":\"), mdx(\"p\", null, \"$$ v(Z) = \\\\frac{1}{d}\\\\sum\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{j=1}^{d}\\\\max(0, \\\\gamma - \\\\sqrt{\\\\mathrm{Var}(Z\"), \"{:,j}) + \\\\epsilon}) $$\"), mdx(\"p\", null, \"where $\\\\gamma$ is a target value for the standard deviation (fixed to one for this paper)\", mdx(\"sup\", {\n    parentName: \"p\",\n    \"id\": \"fnref-2\"\n  }, mdx(\"a\", {\n    parentName: \"sup\",\n    \"href\": \"#fn-2\",\n    \"className\": \"footnote-ref\"\n  }, \"2\")), \", and $\\\\mathrm{Var}(x)$ is the variance estimator:\"), mdx(\"p\", null, \"$$\\\\mathrm{Var}(x) = \\\\frac{1}{n - 1}\\\\sum_{i=1}^n(x_i - \\\\bar{x})^2$$\"), mdx(\"p\", null, \"This forces the variance in a batch of embeddings to be $\\\\gamma$ along each dimension.\"), mdx(\"h3\", {\n    \"id\": \"covariance\"\n  }, \"Covariance\"), mdx(\"p\", null, \"The covariance of matrix $Z$ is given as:\"), mdx(\"p\", null, \"$$C(Z) = \\\\frac{1}{n - 1}\\\\sum_{i=1}^n(Z_i - \\\\bar{Z})(Z_i - \\\\bar{Z})^T$$\"), mdx(\"p\", null, \"with $\\\\bar{Z}$ being the mean embedding across a batch. The actual covariance loss term is taken as the squared off-diagonal coefficients of $C$ that scales with dimensionality $1/d$:\"), mdx(\"p\", null, \"$$c(Z) = \\\\frac{1}{d}\\\\sum\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{i\\\\neq j}C(Z)^2\"), \"{i,j}$$\"), mdx(\"p\", null, \"So that we force the embeddings to learn unit Gaussians similar to the $\\\\beta$-regularization in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/variational-autoencoder\",\n    \"title\": \"variational autoencoder\"\n  }, \"[[variational autoencoder]]\"), \".\"), mdx(\"h3\", {\n    \"id\": \"invariance\"\n  }, \"Invariance\"), mdx(\"p\", null, \"The invariance loss is given by:\"), mdx(\"p\", null, \"$$s(Z,Z') = \\\\frac{1}{n}\\\\sum_i \\\\vert\\\\vert Z_i - Z'_i \\\\vert\\\\vert ^2_2$$\"), mdx(\"p\", null, \"i.e. the mean squared Euclidean distance between each network embedding pair.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This encourages the model to learn the same upstream representation for nominally the same input.\")), mdx(\"h3\", {\n    \"id\": \"the-full-loss\"\n  }, \"The full loss\"), mdx(\"p\", null, \"$$l(Z,Z') = \\\\lambda s(Z,Z') + \\\\mu\", \"{\", \"v(Z) + v(Z')\", \"}\", \" + v\", \"{\", \"c(Z) + c(Z')\", \"}\", \" $$\"), mdx(\"p\", null, \"with hyperparameters $\\\\lambda$, $\\\\mu$, and $\\\\nu$.\"), mdx(\"h2\", {\n    \"id\": \"comments\"\n  }, \"Comments\"), mdx(\"p\", null, \"[variational autoencoder]\", \": variational autoencoder \\\"variational autoencoder\\\"\"), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", {\n    parentName: \"ol\",\n    \"id\": \"fn-1\"\n  }, \"If they're correlated, you are not using each dimension as effectively as you \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"could\"), \".\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#fnref-1\",\n    \"className\": \"footnote-backref\"\n  }, \"\\u21A9\")), mdx(\"li\", {\n    parentName: \"ol\",\n    \"id\": \"fn-2\"\n  }, \"Might be worth seeing how this changes stuff\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#fnref-2\",\n    \"className\": \"footnote-backref\"\n  }, \"\\u21A9\")))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"9c507678-b215-5271-af72-a5590078fdcc","fields":{"slug":"/notes/vicreg","title":"vicreg: Variance-invariance-covariance regularization for self-supervised learning"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"posterior-collapse\"\n  }, \"posterior collapse\"), mdx(\"p\", null, \"An issue primarily related to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/variational-autoencoder\",\n    \"title\": \"variational autoencoder\"\n  }, \"[[variational autoencoder]]\"), \" models, where the output becomes deterministic in a supposedly probabilistic model.\"), mdx(\"p\", null, \"Some annealing schemes, such as [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"cyclical-annealing-schedule-a-simple-approach-to-mitigating-kl-vanishing\",\n    \"title\": \"cyclical-annealing-schedule-a-simple-approach-to-mitigating-kl-vanishing\"\n  }, \"cyclical-annealing-schedule-a-simple-approach-to-mitigating-kl-vanishing\"), \"] is developed to help VAEs learn to encode good latent variables \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"and\"), \" good accuracy in the outputs.\"), mdx(\"p\", null, \"[variational autoencoder]\", \": variational autoencoder \\\"variational autoencoder\\\"\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"568fb177-3b40-5259-99b5-3a6c253faa0f","fields":{"slug":"/notes/posterior collapse","title":"posterior collapse"}}}]},"fields":{"slug":"/notes/variational autoencoder","title":"variational autoencoder"}}},"pageContext":{"id":"0dff8916-86db-5c4c-bdee-c0c7be1cb322"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}