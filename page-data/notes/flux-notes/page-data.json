{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/notes/flux-notes","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"julia, flux, neural-networks\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"flux-notes\"\n  }, \"flux-notes\"), mdx(\"h2\", {\n    \"id\": \"batching\"\n  }, \"Batching\"), mdx(\"p\", null, \"Because Julia is column contiguous, the \\\"observation\\\" dimension is different from Python/\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sklearn\"), \". We expect arrays to be shape $\", \"[F, N]\", \"$ for $F$ features, and $N$ observations.\"), mdx(\"p\", null, \"For this reason, if you're working with single feature regression datasets (i.e. like a toy function, $f(x) = x^3$) then you will want to add a feature dimension with a function like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-julia\"\n  }, \"add_dim(x::Vector) = reshape(x, 1, size(x)...)\\n\")), mdx(\"p\", null, \"Which makes a matrix of dimension \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[1, length(x)]\"), \".\"), mdx(\"h2\", {\n    \"id\": \"mergingsplitting-in-chain\"\n  }, \"Merging/splitting in \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"Chain\")), mdx(\"p\", null, \"Basically follows \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://fluxml.ai/Flux.jl/stable/models/advanced/\"\n  }, \"this tutorial\"), \". For splitting, we define a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Split\"), \" struct like so:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-julia\"\n  }, \"begin\\n    # custom split layer\\n    struct Split{T}\\n      paths::T\\n    end\\n\\n    # constructor method that collects each path into a single array\\n    Split(paths...) = Split(paths)\\n\\n    # make a functor for splitting, so that Chain will recognize it?\\n    Flux.@functor Split\\n\\n    # make a functor for Split, so that it maps the output of the previous layer onto\\n    # every single path afterwards.\\n    (m::Split)(x::AbstractArray) = tuple(map(f -> f(x), m.paths))\\nend\\n\")), mdx(\"p\", null, \"The better way to do this is to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Parallel\"), \" \\\"layer\\\" in Flux. Logically it resembles a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mapreduce\"), \": you send the input to a variable amount of sinks, and the outputs are combined by an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"op\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-julia\"\n  }, \"model = Chain(\\n    Dense(5, 10, relu),\\n    Parallel(\\n        vcat,\\n        [Dense(10, 2) for _ in 1:5]...\\n    )\\n)\\n\")), mdx(\"p\", null, \"This \\\"model\\\" takes a 5-feature input, and transforms to 10-features. The 10-feature arrays are then passed to 5 fully-connected layers, each with an output of 2-features. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"vcat\"), \" operation merges the arrays together in the feature dimension, yielding a 10-feature array.\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"ml-reviews\"\n  }, \"ML Reviews\"), mdx(\"p\", null, \"Welcome to ML Reviews: a Zettelkasten for learning about machine learning methodologies. Primarily, I've been writing notes for myself, with the intention of publishing them here in the hopes of benefiting others.\"), mdx(\"p\", null, \"In lieu of a real index page, here are some topics that will get you started on a journey:\"), mdx(\"h2\", {\n    \"id\": \"paper-reviews\"\n  }, \"Paper reviews\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"notes/scalable-uncertainties-from-deep-ensembles\",\n    \"title\": \"scalable-uncertainties-from-deep-ensembles\"\n  }, \"scalable-uncertainties-from-deep-ensembles\"), \"]; a review on deep ensembles\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"notes/cyclical-annealing-schedule-a-simple-approach-to-mitigating-kl-vanishing\",\n    \"title\": \"cyclical-annealing-schedule-a-simple-approach-to-mitigating-kl-vanishing\"\n  }, \"cyclical-annealing-schedule-a-simple-approach-to-mitigating-kl-vanishing\"), \"]; a review on $\\\\beta$-VAE cyclic annealing\")), mdx(\"h2\", {\n    \"id\": \"topics\"\n  }, \"Topics\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/variational-autoencoder\",\n    \"title\": \"variational autoencoder\"\n  }, \"[[variational autoencoder]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/fast-gradient-sign-method\",\n    \"title\": \"fast gradient sign method\"\n  }, \"[[fast gradient sign method]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"notes/flux-notes\",\n    \"title\": \"flux-notes\"\n  }, \"flux-notes\"), \"]\")), mdx(\"p\", null, \"[variational autoencoder]\", \": notes/variational autoencoder \\\"variational autoencoder\\\"\\n\", \"[fast gradient sign method]\", \": notes/fast gradient sign method \\\"fast gradient sign method\\\"\"), mdx(\"p\", null, \"[variational autoencoder]\", \": notes/variational autoencoder \\\"variational autoencoder\\\"\\n\", \"[fast gradient sign method]\", \": notes/fast gradient sign method \\\"fast gradient sign method\\\"\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"be8ae56f-15a1-5eec-9f16-43ec9bc7a323","fields":{"slug":"/readme","title":"ML Reviews"}}}]},"fields":{"slug":"/notes/flux-notes","title":"flux-notes"}}},"pageContext":{"id":"0d8051f0-dbc5-5ae9-a92d-85f55057d37d"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}