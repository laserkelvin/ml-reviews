{
    "componentChunkName": "component---node-modules-gatsby-theme-kb-src-templates-topic-js",
    "path": "/notes/g2-spectra",
    "result": {"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"g2-spectra\"), mdx(\"h2\", null, \"Todo\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Change noise to be normalized to max of \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"true\"), \", not of noise.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Make Gaussian noise less likely\")), mdx(\"p\", null, \"/date\"), mdx(\"h2\", null, \"Forcing the latent variable on the decoder\"), mdx(\"p\", null, \"By using a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/seq2seq\",\n    \"title\": \"seq2seq\"\n  }, \"[[seq2seq]]\"), \" model, the idea is that the decoder has no choice but to rely on the latent encoding to reconstruct the spectrum, given a timestep. This contrasts with the prior approach of using an autoregressive model, whereby the decoder sees the timesteps \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"and\"), \" noisy photon counts, with the latent variables constituting the initial hidden state. The thing found here was that with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CLVAE\"), \" model, the only probabilistic parts was the initial few steps, and quickly became more or less deterministic for the rest of the architecture.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"#needs-testing actually should try making the latent variable the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"cell state\"), \" not the hidden state. The cell state is unique to LSTMs, and stores the long term memory that might be what's needed to make the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"whole\"), \" spectrum probabilistic.\")), mdx(\"h2\", null, \"Learning at different temporal resolutions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For very long \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/sequential-data\",\n    \"title\": \"sequential-data\"\n  }, \"[[sequential-data]]\"), \", \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"recurrent-models\",\n    \"title\": \"recurrent-models\"\n  }, \"[[recurrent-models]]\"), \" lose sight very quickly because they have to backprop all the way through time: this is very apparent when trying to do a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"seq2seq\"), \" type model for the \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"katex\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"katex-mathml\"\n  }, mdx(\"math\", {\n    parentName: \"span\",\n    \"xmlns\": \"http://www.w3.org/1998/Math/MathML\"\n  }, mdx(\"semantics\", {\n    parentName: \"math\"\n  }, mdx(\"mrow\", {\n    parentName: \"semantics\"\n  }, mdx(\"msub\", {\n    parentName: \"mrow\"\n  }, mdx(\"mi\", {\n    parentName: \"msub\"\n  }, \"g\"), mdx(\"mn\", {\n    parentName: \"msub\"\n  }, \"2\"))), mdx(\"annotation\", {\n    parentName: \"semantics\",\n    \"encoding\": \"application/x-tex\"\n  }, \"g_2\")))), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"katex-html\",\n    \"aria-hidden\": \"true\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"base\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"strut\",\n    \"style\": {\n      \"height\": \"0.625em\",\n      \"verticalAlign\": \"-0.19444em\"\n    }\n  }), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mord\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mord mathnormal\",\n    \"style\": {\n      \"marginRight\": \"0.03588em\"\n    }\n  }, \"g\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"msupsub\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"vlist-t vlist-t2\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"vlist-r\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"vlist\",\n    \"style\": {\n      \"height\": \"0.30110799999999993em\"\n    }\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"style\": {\n      \"top\": \"-2.5500000000000003em\",\n      \"marginLeft\": \"-0.03588em\",\n      \"marginRight\": \"0.05em\"\n    }\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"pstrut\",\n    \"style\": {\n      \"height\": \"2.7em\"\n    }\n  }), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"sizing reset-size6 size3 mtight\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mord mtight\"\n  }, \"2\")))), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"vlist-s\"\n  }, \"\\u200B\")), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"vlist-r\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"vlist\",\n    \"style\": {\n      \"height\": \"0.15em\"\n    }\n  }, mdx(\"span\", {\n    parentName: \"span\"\n  })))))))))), \" spectra, which end up simply predicting the mean of the data regardless of the inputs (taken from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sleek-monkey-36\"), \"):\")), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"2021-08-23-17-24-07.png\",\n    \"alt\": null\n  })), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For this project, I developed a model that learns the same sequential data at different resolutions, hoping that this will solve this problem\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The figure below shows the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/architecture\",\n    \"title\": \"architecture\"\n  }, \"[[architecture]]\"), \" plan: basically for every \\\"Temporal downsample\\\" layer, we downsample the timesteps and photon counts, with the former being inputs to an RNN model. The RNN predicts the photon counts at each timestep, and is compared with the corresponding downsampled ground truth spectrum.\")), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/ml-reviews/bcc200e81ca93057300cc4552c15c22d/g2-temporal-model.svg\",\n    \"alt\": \"downsample-architecture\"\n  })), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For the training loop, a shared \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"output\"), \" RNN is used to convert the RNN spectrum to the corresponding downsampled prediction: for inference, this is not needed as we probably just want the final output.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The important thing with this architecture, is that hopefully the low-resolution (and therefore correspondingly short sequences) are easier to learn from, and carry information over to progressively higher resolutions.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"#needs-research because I don't know if someone else has done this before.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","private":false},"outboundReferences":[{"contextLine":"- For very long [[sequential-data]], [[recurrent-models]] lose sight very quickly because they have to backprop all the way through time: this is very apparent when trying to do a `seq2seq` type model for the $g_2$ spectra, which end up simply predicting the mean of the data regardless of the inputs (taken from `sleek-monkey-36`):","targetAnchor":null,"refWord":"recurrent-models","target":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"recurrent-models\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"aff8cb01-bccd-557b-a232-54efdcecb28d","fields":{"slug":"/notes/recurrent-models","title":"recurrent-models"}}}}],"inboundReferences":[]},"fields":{"slug":"/notes/g2-spectra","title":"g2-spectra"}}},"pageContext":{"id":"5eef8e6b-89b5-519b-ab7e-cf195c797509","refWordMdxSlugDict":{"recurrent-models":"notes/recurrent-models"}}},
    "staticQueryHashes": ["2221750479","2380733210","2768355698","63159454","847517413"]}